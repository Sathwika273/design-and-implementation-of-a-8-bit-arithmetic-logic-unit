$date
	Tue Feb 24 04:13:58 2026
$end

$version
	Synopsys VCS version X-2025.06-SP1_Full64
$end

$timescale
	1ns
$end

$comment Csum: 1 43315df540933998 $end


$scope module tb $end
$var reg 1 ! init $end
$var reg 4 " opco [3:0] $end
$var reg 8 # a [7:0] $end
$var reg 8 $ b [7:0] $end
$var wire 16 % deco [15:0] $end
$var wire 8 & add [7:0] $end
$var wire 8 ' sub [7:0] $end
$var wire 16 ( mul [15:0] $end
$var wire 8 ) div [7:0] $end
$var wire 8 * andd [7:0] $end
$var wire 8 + orr [7:0] $end
$var wire 8 , nott [7:0] $end
$var wire 8 - nandd [7:0] $end
$var wire 8 . norr [7:0] $end
$var wire 8 / xorr [7:0] $end
$var wire 8 0 refresh [7:0] $end
$var wire 8 1 comp [7:0] $end
$var wire 8 2 sh_result [7:0] $end
$var wire 8 3 ro_result [7:0] $end
$var wire 8 4 s [7:0] $end
$var wire 8 5 ccin [7:0] $end
$var wire 4 6 cc [3:0] $end
$var wire 5 7 rfetch [4:0] $end
$var wire 16 8 out [15:0] $end
$var wire 1 9 carryflag $end
$var wire 1 : logflag $end
$var wire 1 ; zeroflag $end
$var wire 1 < shiftflag $end
$var wire 1 = doneflag $end
$var wire 9 > temp_sum [8:0] $end
$var wire 8 ? shl [7:0] $end
$var wire 8 @ shr [7:0] $end
$var wire 8 A shll [7:0] $end
$var wire 8 B shrr [7:0] $end
$var wire 8 C rol [7:0] $end
$var wire 8 D ror [7:0] $end
$var wire 8 E roll [7:0] $end
$var wire 8 F rorr [7:0] $end
$var wire 8 G g [7:0] $end
$var wire 8 H xs3 [7:0] $end
$var wire 8 I xs5 [7:0] $end
$var wire 8 J bcd [7:0] $end
$var wire 1 K xs3tens_bit $end
$var wire 1 L xs5tens_bit $end
$var wire 1 M bcdtens_bit $end
$var wire 1 N arth_flag $end
$var wire 1 O logi_flag $end
$var wire 1 P comp_flag $end
$var wire 1 Q shft_flag $end
$var wire 1 R code_flag $end

$scope module uut $end
$var wire 1 ! init $end
$var wire 4 " opco [3:0] $end
$var wire 8 # a [7:0] $end
$var wire 8 $ b [7:0] $end
$var reg 16 % deco [15:0] $end
$var reg 8 & add [7:0] $end
$var reg 8 ' sub [7:0] $end
$var reg 16 ( mul [15:0] $end
$var reg 8 ) div [7:0] $end
$var reg 8 * andd [7:0] $end
$var reg 8 + orr [7:0] $end
$var reg 8 , nott [7:0] $end
$var reg 8 - nandd [7:0] $end
$var reg 8 . norr [7:0] $end
$var reg 8 / xorr [7:0] $end
$var reg 8 0 refresh [7:0] $end
$var reg 8 1 comp [7:0] $end
$var reg 8 2 sh_result [7:0] $end
$var reg 8 3 ro_result [7:0] $end
$var reg 8 4 s [7:0] $end
$var reg 8 5 ccin [7:0] $end
$var reg 4 6 cc [3:0] $end
$var reg 1 K xs3tens_bit $end
$var reg 1 L xs5tens_bit $end
$var reg 1 M bcdtens_bit $end
$var reg 5 7 rfetch [4:0] $end
$var reg 16 8 out [15:0] $end
$var reg 1 9 carryflag $end
$var reg 1 : logflag $end
$var reg 1 ; zeroflag $end
$var reg 1 < shiftflag $end
$var reg 1 = doneflag $end
$var reg 9 S temp_sum [8:0] $end
$var wire 1 T s1 $end
$var wire 1 U s2 $end
$var reg 8 V shl [7:0] $end
$var reg 8 W shr [7:0] $end
$var reg 8 X shll [7:0] $end
$var reg 8 Y shrr [7:0] $end
$var reg 8 Z rol [7:0] $end
$var reg 8 [ ror [7:0] $end
$var reg 8 \ roll [7:0] $end
$var reg 8 ] rorr [7:0] $end
$var reg 8 ^ g [7:0] $end
$var reg 8 _ xs3 [7:0] $end
$var reg 8 ` xs5 [7:0] $end
$var reg 8 a bcd [7:0] $end
$var reg 1 b arth_flag $end
$var reg 1 c logi_flag $end
$var reg 1 d comp_flag $end
$var reg 1 e shft_flag $end
$var reg 1 f code_flag $end
$upscope $end

$upscope $end

$enddefinitions $end

#0
$dumpvars
0b
0f
0d
0!
0c
xT
xU
0e
0M
09
0=
0:
0<
0K
0L
0;
bxxxxxxxx #
bxxxxxxxx $
b00000000 a
b00000000 ^
bxxxx "
b00000000 Z
b00000000 \
b00000000 [
b00000000 ]
b00000000 V
b00000000 X
b00000000 W
b00000000 Y
bxxxxxxxxx S
b00000000 &
b00000000 *
b0000 6
b00000000 5
b00000000 1
b0000000000000000 %
b00000000 )
b0000000000000000 (
b00000000 -
b00000000 .
b00000000 ,
b00000000 +
b0000000000000000 8
b00000000 0
b00000 7
b00000000 3
b00000000 4
b00000000 2
b00000000 '
b00000000 /
b00000000 _
b00000000 `
zR
zQ
zP
zO
zN
bzzzzzzzz J
bzzzzzzzz I
bzzzzzzzz H
bzzzzzzzz G
bzzzzzzzz F
bzzzzzzzz E
bzzzzzzzz D
bzzzzzzzz C
bzzzzzzzz B
bzzzzzzzz A
bzzzzzzzz @
bzzzzzzzz ?
bzzzzzzzzz >
$end
#5
b11100010 #
b10001100 $
0U
1T
1!
b10001100 5
#10
b0000 "
#15
b0001 "
b0000000000000001 %
19
b01101110 &
b101101110 S
b0000000001101110 8
#20
b0010 "
b0000000000000010 %
09
b01010110 '
b0000000001010110 8
#25
b0011 "
b0000000000000100 %
b0111101110011000 (
b0111101110011000 8
#30
b0100 "
b0000000000001000 %
b00000001 )
b0000000000000001 8
#35
b0101 "
b0000000000010000 %
1:
b10000000 *
b0000000010000000 8
#40
b0110 "
b0000000000100000 %
b11101110 +
b0000000011101110 8
#45
b0111 "
b0000000001000000 %
b00011101 ,
b0000000000011101 8
#50
b1000 "
b0000000010000000 %
b01111111 -
b0000000001111111 8
#55
b1001 "
b0000000100000000 %
b00010001 .
b0000000000010001 8
#60
b1010 "
b0000001000000000 %
b01101110 /
b0000000001101110 8
#65
b1011 "
b0000010000000000 %
0:
b0000000000000000 8
#70
b1100 "
b0000000000000000 %
b0000100000000000 %
b10000000 1
b0000000010000000 8
#75
b1101 "
b0000000000000000 %
b11110111 4
b11110111 3
b11110101 2
b0001000000000000 %
b11100010 \
b01110001 [
b11000101 Z
b01110001 W
1<
b11000100 V
b0000000011110111 8
b11110111 5
#80
b1110 "
b0000000000000000 %
b0101 6
b0010000000000000 %
1=
1M
b00000101 a
b0000000000000101 8
#85
b1111 "
b0000000000000000 %
0=
0M
b11111 7
1f
1e
1d
1c
1b
b0100000000000000 %
b0000000000011111 8
